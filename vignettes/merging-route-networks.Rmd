---
title: "Merging route networks"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Merging route networks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  # # Uncomment to speed-up build
  # eval = FALSE,
  comment = "#>",
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
# devtools::load_all()
sf::sf_use_s2(FALSE)
```

```{r setup}
library(stplanr)
library(dplyr)
library(tmap)
rnet_x = sf::read_sf("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_x_ed.geojson")
rnet_y = sf::read_sf("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_y_ed.geojson")
# dups = duplicated(rnet_x$geometry)
# summary(dups)
# rnet_x = rnet_x |>
#   filter(!dups)
# sf::write_sf(rnet_x, "~/github/ropensci/stplanr/rnet_x_ed.geojson", delete_dsn = TRUE)
```

```{r}
# Checking reults with adding funtions to calcualte the angle
tmap_mode("view")
funs = list(value = sum, Quietness = mean)
brks = c(0, 100, 500, 1000, 5000,10000)
rnet_merged = rnet_merge(rnet_x, rnet_y, dist = 10, segment_length = 10, funs = funs)
#rnet_merged$identifier <- NULL
# rnet_merged$value[is.na(rnet_merged$value)] <- 0
m1 = tm_shape(rnet_y) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)
m2 = tm_shape(rnet_merged) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)
tmap_arrange(m1, m2, sync = TRUE)

```

# Target network preprocessing

We pre-processed the input simple geometry to make it even simpler as shown below.

```{r, out.width="100%", fig.width=8, fig.height=6}
tmap_mode("view")
# nrow(rnet_x)
# summary(sf::st_length(rnet_x))
plot(sf::st_geometry(rnet_x))
rnet_x = rnet_subset(rnet_x, rnet_y, dist = 20)
# nrow(rnet_x)
# plot(sf::st_geometry(rnet_x))
rnet_x = rnet_subset(rnet_x, rnet_y, dist = 20, min_length = 5)
# summary(sf::st_length(rnet_x))
# nrow(rnet_x)
# plot(sf::st_geometry(rnet_x))
rnet_x = rnet_subset(rnet_x, rnet_y, dist = 20, rm_disconnected = TRUE)
# nrow(rnet_x)
plot(sf::st_geometry(rnet_x))
```

The initial merged result was as follows.


```{r}
funs = list(value = sum, Quietness = mean)
brks = c(0, 100, 500, 1000, 5000)
rnet_merged = rnet_merge(rnet_x, rnet_y, dist = 20, segment_length = 20, funs = funs)
m1 = tm_shape(rnet_y) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)  +
  tm_scale_bar()
m2 = tm_shape(rnet_merged) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)
tmap_arrange(m1, m2, sync = TRUE)
```

We can more reduce the minimum segment length to ensure fewer NA values in the outputs:

```{r}
rnet_merged = rnet_merge(rnet_x, rnet_y, dist = 20, segment_length = 10, funs = funs)
m1 = tm_shape(rnet_y) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)
m2 = tm_shape(rnet_merged) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)
tmap_arrange(m1, m2, sync = TRUE)
```

Reducing the max length of the complex route network led to the following result.

```{r}
rnet_merged = rnet_merge(rnet_x, rnet_y, dist = 20, segment_length = 5, funs = funs, dist_subset = 30)
m1 = tm_shape(rnet_y) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)
m2 = tm_shape(rnet_merged) + tm_lines("value", palette = "viridis", lwd = 5, breaks = brks)
tmap_arrange(m1, m2, sync = TRUE)
```

```{r, echo=FALSE, eval=FALSE}
sum(rnet_merged$value * sf::st_length(rnet_merged), na.rm = TRUE)
sum(rnet_y$value * sf::st_length(rnet_y), na.rm = TRUE)
```

```{r}
dist = 10
length_y = TRUE
key_column = 1,
subset_x = TRUE
dist_subset = NULL
segment_length = 0
endCapStyle = "SQUARE"
contains = FALSE
mask_function = function(angle) (angle < 40) | (angle > 140)

if (is.null(dist_subset)) {
  dist_subset = dist + 1
}
dist_subset

if (subset_x) {
  dim(rnet_x)
  rnet_x = rnet_subset(rnet_x, rnet_y, dist = dist_subset)
  dim(rnet_x)
}

rnet_x_buffer = geo_buffer(rnet_x, dist = dist, nQuadSegs = 2, endCapStyle = endCapStyle)
# Store the original geometry of 'rnet_x' in the buffer object
rnet_x_buffer$corr_line_geometry_buffer = rnet_x$geometry


m1 <- mapview(rnet_x_buffer["geometry"])
buffer_line <- as(rnet_x_buffer["corr_line_geometry_buffer"], "Spatial")
buffer_line_sf <- st_as_sf(buffer_line)
m2 <- mapview(buffer_line_sf["corr_line_geometry_buffer"],color  = 'red', lwd = 2)
m1 + m2 


if (segment_length > 0) {
  dim(rnet_y)
  rnet_y = line_segment(rnet_y, segment_length = segment_length)
  dim(rnet_y)
}

if (length_y) {
  rnet_y$length_y = as.numeric(sf::st_length(rnet_y))
}
names(rnet_y)

rnet_y_centroids = sf::st_centroid(rnet_y)
# Store the original geometry of 'rnet_y' in the centroid object
rnet_y_centroids$corr_line_geometry_point = rnet_y$geometry

m1 <- mapview(rnet_y_centroids["geometry"])
centroids_line <- as(rnet_y_centroids["corr_line_geometry_point"], "Spatial")
centroids_line_sf <- st_as_sf(buffer_line)
m2 <- mapview(centroids_line_sf["corr_line_geometry_point"],color  = 'red')
m3 <- mapview(rnet_x_buffer["geometry"])
m1 + m2 + m3

rnetj = sf::st_join(rnet_x_buffer, rnet_y_centroids)
# Calculate angles between the buffer geometry and the point geometry for each row
rnetj$angle = sapply(1:nrow(rnetj), function(i) {
calculate_angle(get_vector(rnetj$corr_line_geometry_buffer[[i]]), get_vector(rnetj$corr_line_geometry_point[[i]]))
})  
mask_function
mask = mask_function(rnetj$angle)
filtered_rnetj <- rnetj[mask, ]
dim(rnetj)
dim(filtered_rnetj)
rnetj = filtered_rnetj

m1 <- mapview(rnetj,color = 'red', fill.color = 'red')
m2 <- mapview(filtered_rnetj,color = 'blue', fill.color = 'blue')

m1 + m2

```